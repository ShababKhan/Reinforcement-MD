\"\"\"\nThis module provides functions for calculating collective variables (CVs)\nbased on Center of Mass (COM) distances and for interacting with pre-computed\nfree energy (FE) maps.\n\"\"\"\n\nimport MDAnalysis as mda\nimport numpy as np\n\n# --- Assumptions for CRBN/DDB1 Domain Selections (based on Fig. S1 and PDB 6XR2) ---\n# These selections are crucial and are based on common domain definitions for CRBN and DDB1.\n# For a specific experimental setup, these ranges should be verified against the\n# PDB file and the reference paper.\n# PDB 6XR2: CRBN (Chain A, 1-320), DDB1 (Chain B, ~200-1140 for large propeller)\nCRBN_NTD_SELECTION = \"segid A and resid 1:50 and protein\"\nCRBN_HBD_SELECTION = \"segid A and resid 51:249 and protein\" # Haploinsufficiency Binding Domain\nCRBN_CTD_SELECTION = \"segid A and resid 250:320 and protein\"\nDDB1_BPC_SELECTION = \"segid B and resid 200:600 and protein\" # DDB1 Beta-Propeller Domain\n\ndef calculate_cvs(universe_frame: mda.Universe | mda.AtomGroup) -> np.ndarray:\n    \"\"\"\n    Calculates three collective variables (CV1, CV2, CV3) based on the\n    Center of Mass (COM) distances of CRBN and DDB1 domains, as described\n    in Fig. S1 of the paper.\n\n    The CVs are defined as distances between COMs:\n    1. CV1: Distance(CRBN-CTD COM, CRBN-NTD COM)\n    2. CV2: Distance(CRBN-CTD COM, CRBN-HBD COM)\n    3. CV3: Distance(CRBN-CTD COM, DDB1-BPC COM)\n\n    Args:\n        universe_frame (MDAnalysis.Universe | MDAnalysis.AtomGroup):\n            An MDAnalysis Universe object or an AtomGroup representing the\n            system at a specific frame. The selection strings for the domains\n            will be applied to this object.\n\n    Returns:\n        numpy.ndarray: A 1D NumPy array of shape (3,) containing the calculated\n                       [CV1, CV2, CV3] distances in Ångströms.\n\n    Raises:\n        ValueError: If any of the domain selections result in an empty AtomGroup,\n                    indicating missing or incorrectly specified domains.\n    \"\"\"\n    # Select atoms for each domain\n    crbn_ntd_atoms = universe_frame.select_atoms(CRBN_NTD_SELECTION)\n    crbn_hbd_atoms = universe_frame.select_atoms(CRBN_HBD_SELECTION)\n    crbn_ctd_atoms = universe_frame.select_atoms(CRBN_CTD_SELECTION)\n    ddb1_bpc_atoms = universe_frame.select_atoms(DDB1_BPC_SELECTION)\n\n    # Check if any selection is empty, which would indicate a problem\n    if not crbn_ntd_atoms:\n        raise ValueError(f\"CRBN-NTD selection ({CRBN_NTD_SELECTION}) yielded no atoms.\")\n    if not crbn_hbd_atoms:\n        raise ValueError(f\"CRBN-HBD selection ({CRBN_HBD_SELECTION}) yielded no atoms.\")\n    if not crbn_ctd_atoms:\n        raise ValueError(f\"CRBN-CTD selection ({CRBN_CTD_SELECTION}) yielded no atoms.\")\n    if not ddb1_bpc_atoms:\n        raise ValueError(f\"DDB1-BPC selection ({DDB1_BPC_SELECTION}) yielded no atoms.\")\n\n    # Calculate Center of Mass for each domain\n    com_crbn_ntd = crbn_ntd_atoms.center_of_mass()\n    com_crbn_hbd = crbn_hbd_atoms.center_of_mass()\n    com_crbn_ctd = crbn_ctd_atoms.center_of_mass()\n    com_ddb1_bpc = ddb1_bpc_atoms.center_of_mass()\n\n    # Calculate distances\n    # Distance function: np.linalg.norm(pos1 - pos2)\n    cv1 = np.linalg.norm(com_crbn_ctd - com_crbn_ntd)\n    cv2 = np.linalg.norm(com_crbn_ctd - com_crbn_hbd)\n    cv3 = np.linalg.norm(com_crbn_ctd - com_ddb1_bpc)\n\n    return np.array([cv1, cv2, cv3])\n\ndef generate_fe_map_placeholder(cv_grid_points: tuple[int, int, int]) -> np.ndarray:\n    \"\"\"\n    Generates a placeholder 3D free energy (FE) map grid.\n\n    This function is a placeholder for the eventual integration of a pre-computed\n    FE map. For now, it returns a 3D NumPy array filled with zeros, representing\n    the FE map grid with specified dimensions.\n\n    Args:\n        cv_grid_points (tuple[int, int, int]): A tuple specifying the number of\n                                              grid points along each of the three\n                                              CV dimensions (e.g., (100, 100, 100)).\n\n    Returns:\n        numpy.ndarray: A 3D NumPy array (e.g., of zeros) representing the FE map grid.\n    \"\"\"\
    if len(cv_grid_points) != 3 or not all(isinstance(x, int) and x > 0 for x in cv_grid_points):\n        raise ValueError(\"cv_grid_points must be a tuple of 3 positive integers.\")\n    return np.zeros(cv_grid_points)\n\ndef snap_cv_to_fe_map_grid(\n    cv_values: np.ndarray,\n    fe_map_grid_dims: tuple[int, int, int],\n    fe_map_grid_bounds: list[tuple[float, float]]\n) -> tuple[int, int, int]:\n    \"\"\"\n    Snaps a set of collective variable (CV) coordinates to the closest grid point\n    within a defined free energy (FE) map grid.\n\n    The function first normalizes each CV value based on its min/max bounds,\n    then scales it to the grid dimensions to find the corresponding grid index.\n    Values outside the bounds are clamped to the nearest edge grid point.\n\n    Args:\n        cv_values (numpy.ndarray): A 1D NumPy array of 3 float values,\n                                  representing [CV1, CV2, CV3] for a frame.\n        fe_map_grid_dims (tuple[int, int, int]): A tuple specifying the number of\n                                                grid points along each CV dimension\n                                                (e.g., (100, 100, 100)).\n        fe_map_grid_bounds (list[tuple[float, float]]): A list of 3 tuples,\n                                                      where each tuple defines the\n                                                      (min_value, max_value) for\n                                                      each respective CV dimension.\n                                                      E.g., [(0, 10), (0, 15), (5, 20)].\n\n    Returns:\n        tuple[int, int, int]: A tuple of 3 integers representing the (i, j, k)\n                              grid indices for the snapped CV values.\n    \"\"\"\
    if cv_values.shape != (3,):\n        raise ValueError(\"cv_values must be a 1D NumPy array of shape (3,).\")\n    if len(fe_map_grid_dims) != 3 or not all(isinstance(x, int) and x > 0 for x in fe_map_grid_dims):\n        raise ValueError(\"fe_map_grid_dims must be a tuple of 3 positive integers.\")\n    if len(fe_map_grid_bounds) != 3 or not all(isinstance(b, tuple) and len(b) == 2 for b in fe_map_grid_bounds):\n        raise ValueError(\"fe_map_grid_bounds must be a list of 3 (min, max) tuples.\")\n\n    grid_indices = [0, 0, 0]\n    for i in range(3):\n        cv_min, cv_max = fe_map_grid_bounds[i]\n        grid_dim = fe_map_grid_dims[i]\n        cv_val = cv_values[i]\n\n        if cv_max <= cv_min:\n            raise ValueError(f\"Invalid bounds for CV{i+1}: max ({cv_max}) must be greater than min ({cv_min}).\")\n\n        # Normalize CV value to [0, 1] range\n        normalized_cv = (cv_val - cv_min) / (cv_max - cv_min)\n\n        # Clamp normalized value to [0, 1] to handle out-of-bounds inputs\n        normalized_cv = np.clip(normalized_cv, 0.0, 1.0)\n\n        # Scale to grid index. We subtract a small epsilon from grid_dim to ensure\n        # the max value maps to (grid_dim - 1) index, not grid_dim.\n        # This prevents an index out of bounds for `np.zeros(grid_dim)` array.\n        grid_index = int(np.floor(normalized_cv * (grid_dim - 0.000001))) # ensure index is never grid_dim\n        grid_indices[i] = int(np.clip(grid_index, 0, grid_dim - 1)) # Final clip just in case\n\n    return tuple(grid_indices)\n